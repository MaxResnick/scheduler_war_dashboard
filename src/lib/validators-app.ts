/**
 * Service for accessing validator data.
 * Uses pre-cached data from build time (generated by scripts/fetch-validator-names.ts)
 * BAM validators are fetched dynamically with 30-minute caching from bam.dev/explorer API
 */

import "server-only";
import { unstable_cache } from "next/cache";
import cachedNames from "../data/validator-names.json";
import cachedValidators from "../data/validators.json";
import cachedBamValidators from "../data/bam-validators.json";

const BAM_API_URL = "https://explorer.bam.dev/api/v1/validators";
const CACHE_REVALIDATE_SECONDS = 1800; // 30 minutes

// Type for BAM validators from the API
type BamValidator = {
  validator_pubkey: string;
  bam_node_connection: string;
  stake: number;
  stake_percentage: number;
};

// Type for the cached data structures
type CachedValidatorNames = {
  generatedAt: string;
  count: number;
  names: Record<string, string>;
};

export type ValidatorData = {
  account: string;
  name: string | null;
  activeStake: number;
  softwareClient: string;
};

type CachedValidators = {
  generatedAt: string;
  count: number;
  validators: ValidatorData[];
};

// Validators that report "Unknown" but are NOT Harmonic
// These stay as "Unknown" while all other "Unknown" validators become "Harmonic"
const notHarmonicValidators = new Set<string>([
  // Currently empty - OtterSec now classified as Harmonic
]);

// Validators that advertise as Jito Agave on gossip but are actually running Harmonic
const jitoButActuallyHarmonic = new Set([
  "Hz5aLvpKScNWoe9YZWxBLrQA3qzHJivBGtfciMekk8m5",
  "4mtXJ5pUcMMB4t8cLbi7zfDJCHfYLRrQb4qSLmh57sKL",
  "84gC25fbFKYueR9WEfreUysk1n3ZFxLFDDjbyqeqGpoW",
  "EXckihF3qmguH5znjhfzLvHsbk2E3nEW2DqNh4MMnDMm",
  "5ivRNcK1yThcK3koZR1oikAfuNm6rj1LceMskayoVSzc",
]);

const validatorNames = cachedNames as CachedValidatorNames;
const rawValidatorsData = cachedValidators as CachedValidators;

// Get BAM validators from local cache (updated at build time)
function getLocalBamValidators(): string[] {
  const data = cachedBamValidators as BamValidator[];
  return data.map((v) => v.validator_pubkey);
}

/**
 * Fetch BAM validators from the explorer API with caching
 * Falls back to local cached file if API fails
 * Returns an array since unstable_cache serializes data (Set won't survive)
 */
const fetchBamValidators = unstable_cache(
  async (): Promise<string[]> => {
    try {
      console.log("[validators-app] Fetching BAM validators from API...");
      const response = await fetch(BAM_API_URL, {
        next: { revalidate: CACHE_REVALIDATE_SECONDS },
      });
      if (!response.ok) {
        console.error(`[validators-app] BAM API returned ${response.status}, using local cache`);
        return getLocalBamValidators();
      }
      const data: BamValidator[] = await response.json();
      console.log(`[validators-app] Fetched ${data.length} BAM validators`);
      return data.map((v) => v.validator_pubkey);
    } catch (error) {
      console.error("[validators-app] Failed to fetch BAM validators, using local cache:", error);
      return getLocalBamValidators();
    }
  },
  ["bam-validators"],
  { revalidate: CACHE_REVALIDATE_SECONDS }
);

/**
 * Get processed validators with BAM and Harmonic overrides applied
 */
async function getProcessedValidators(): Promise<ValidatorData[]> {
  const bamValidatorsList = await fetchBamValidators();
  const bamValidatorPubkeys = new Set(bamValidatorsList);

  return rawValidatorsData.validators.map((v) => {
    let softwareClient = v.softwareClient;

    // Validators falsely advertising as Jito but actually running Harmonic
    if (jitoButActuallyHarmonic.has(v.account)) {
      softwareClient = "Harmonic";
    }
    // BAM validators from confirmed list
    else if (bamValidatorPubkeys.has(v.account)) {
      softwareClient = "AgaveBam";
    }
    // If gossip says BAM but not in confirmed list, it's regular Jito
    else if (v.softwareClient === "AgaveBam") {
      softwareClient = "JitoLabs";
    }
    // Most "Unknown" validators are Harmonic, except those in exclusion list
    else if (v.softwareClient === "Unknown" && !notHarmonicValidators.has(v.account)) {
      softwareClient = "Harmonic";
    }

    return { ...v, softwareClient };
  });
}

/**
 * Get validator name by account address.
 * Returns null if not found or no name available.
 */
export function getValidatorName(account: string): string | null {
  return validatorNames.names[account] ?? null;
}

/**
 * Get multiple validator names at once.
 * Returns a map of account -> name (null if not found).
 */
export function getValidatorNames(accounts: string[]): Map<string, string | null> {
  const result = new Map<string, string | null>();
  for (const account of accounts) {
    result.set(account, validatorNames.names[account] ?? null);
  }
  return result;
}

/**
 * Search validators by name or address prefix.
 * Returns matches with both name and address.
 */
export function searchValidators(
  query: string,
  limit: number = 10
): Array<{ account: string; name: string | null }> {
  const queryLower = query.toLowerCase();
  const results: Array<{ account: string; name: string | null }> = [];

  for (const [account, name] of Object.entries(validatorNames.names)) {
    const nameMatches = name.toLowerCase().includes(queryLower);
    const accountMatches = account.toLowerCase().startsWith(queryLower);

    if (nameMatches || accountMatches) {
      results.push({ account, name });
      if (results.length >= limit) {
        break;
      }
    }
  }

  return results;
}

/**
 * Get all cached validator names.
 * Returns the full names object.
 */
export function getAllValidatorNames(): Record<string, string> {
  return validatorNames.names;
}

/**
 * Get cache metadata (when it was generated, count, etc.)
 */
export function getCacheInfo(): { generatedAt: string; count: number } {
  return {
    generatedAt: validatorNames.generatedAt,
    count: validatorNames.count,
  };
}

/**
 * Get all validators with full data including stake and scheduler type.
 * Returns an array sorted by stake descending.
 * BAM validator list is refreshed every 30 minutes.
 */
export async function getAllValidators(): Promise<ValidatorData[]> {
  return getProcessedValidators();
}

/**
 * Get validators grouped by scheduler type (software client).
 * Returns a map of softwareClient -> validators array.
 */
export async function getValidatorsBySchedulerType(): Promise<Map<string, ValidatorData[]>> {
  const validators = await getProcessedValidators();
  const grouped = new Map<string, ValidatorData[]>();

  for (const validator of validators) {
    const existing = grouped.get(validator.softwareClient) ?? [];
    existing.push(validator);
    grouped.set(validator.softwareClient, existing);
  }

  return grouped;
}

/**
 * Get total stake by scheduler type.
 * Returns a map of softwareClient -> total stake.
 */
export async function getStakeBySchedulerType(): Promise<Map<string, number>> {
  const validators = await getProcessedValidators();
  const stakeMap = new Map<string, number>();

  for (const validator of validators) {
    const current = stakeMap.get(validator.softwareClient) ?? 0;
    stakeMap.set(validator.softwareClient, current + validator.activeStake);
  }

  return stakeMap;
}
