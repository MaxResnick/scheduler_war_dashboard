/**
 * Service for accessing validator data.
 * Uses pre-cached data from build time (generated by scripts/fetch-validator-names.ts)
 * BAM validators are sourced from bam.dev/explorer API as the authoritative source
 */

import cachedNames from "../data/validator-names.json";
import bamValidatorsRaw from "../data/bam-validators.json";

// Type for BAM validators from the API
type BamValidator = {
  validator_pubkey: string;
  bam_node_connection: string;
  stake: number;
  stake_percentage: number;
};

// Create a set of confirmed BAM validator pubkeys for fast lookup
const bamValidatorPubkeys = new Set(
  (bamValidatorsRaw as BamValidator[]).map((v) => v.validator_pubkey)
);

// Validators that report "Unknown" but are NOT Harmonic
// These stay as "Unknown" while all other "Unknown" validators become "Harmonic"
const notHarmonicValidators = new Set([
  "3psxMyr7rQzywVp1MXKd1XFmFz33NjydzCoJx9t2sMQW", // OtterSec
]);

// Type for the cached data structures
type CachedValidatorNames = {
  generatedAt: string;
  count: number;
  names: Record<string, string>;
};

export type ValidatorData = {
  account: string;
  name: string | null;
  activeStake: number;
  softwareClient: string;
};

type CachedValidators = {
  generatedAt: string;
  count: number;
  validators: ValidatorData[];
};

const validatorNames = cachedNames as CachedValidatorNames;

// Try to load validators data, fall back to empty if not available
let validatorsData: CachedValidators;
try {
  const rawData = require("../data/validators.json") as CachedValidators;
  // Override softwareClient based on confirmed data sources
  validatorsData = {
    ...rawData,
    validators: rawData.validators.map((v) => {
      let softwareClient = v.softwareClient;

      // BAM validators from confirmed list
      if (bamValidatorPubkeys.has(v.account)) {
        softwareClient = "AgaveBam";
      }
      // If gossip says BAM but not in confirmed list, it's regular Jito
      else if (v.softwareClient === "AgaveBam") {
        softwareClient = "JitoLabs";
      }
      // Most "Unknown" validators are Harmonic, except those in exclusion list
      else if (v.softwareClient === "Unknown" && !notHarmonicValidators.has(v.account)) {
        softwareClient = "Harmonic";
      }

      return { ...v, softwareClient };
    }),
  };
} catch {
  validatorsData = { generatedAt: "", count: 0, validators: [] };
}

/**
 * Get validator name by account address.
 * Returns null if not found or no name available.
 */
export function getValidatorName(account: string): string | null {
  return validatorNames.names[account] ?? null;
}

/**
 * Get multiple validator names at once.
 * Returns a map of account -> name (null if not found).
 */
export function getValidatorNames(accounts: string[]): Map<string, string | null> {
  const result = new Map<string, string | null>();
  for (const account of accounts) {
    result.set(account, validatorNames.names[account] ?? null);
  }
  return result;
}

/**
 * Search validators by name or address prefix.
 * Returns matches with both name and address.
 */
export function searchValidators(
  query: string,
  limit: number = 10
): Array<{ account: string; name: string | null }> {
  const queryLower = query.toLowerCase();
  const results: Array<{ account: string; name: string | null }> = [];

  for (const [account, name] of Object.entries(validatorNames.names)) {
    const nameMatches = name.toLowerCase().includes(queryLower);
    const accountMatches = account.toLowerCase().startsWith(queryLower);

    if (nameMatches || accountMatches) {
      results.push({ account, name });
      if (results.length >= limit) {
        break;
      }
    }
  }

  return results;
}

/**
 * Get all cached validator names.
 * Returns the full names object.
 */
export function getAllValidatorNames(): Record<string, string> {
  return validatorNames.names;
}

/**
 * Get cache metadata (when it was generated, count, etc.)
 */
export function getCacheInfo(): { generatedAt: string; count: number } {
  return {
    generatedAt: validatorNames.generatedAt,
    count: validatorNames.count,
  };
}

/**
 * Get all validators with full data including stake and scheduler type.
 * Returns an array sorted by stake descending.
 */
export function getAllValidators(): ValidatorData[] {
  return validatorsData.validators;
}

/**
 * Get validators grouped by scheduler type (software client).
 * Returns a map of softwareClient -> validators array.
 */
export function getValidatorsBySchedulerType(): Map<string, ValidatorData[]> {
  const grouped = new Map<string, ValidatorData[]>();

  for (const validator of validatorsData.validators) {
    const existing = grouped.get(validator.softwareClient) ?? [];
    existing.push(validator);
    grouped.set(validator.softwareClient, existing);
  }

  return grouped;
}

/**
 * Get total stake by scheduler type.
 * Returns a map of softwareClient -> total stake.
 */
export function getStakeBySchedulerType(): Map<string, number> {
  const stakeMap = new Map<string, number>();

  for (const validator of validatorsData.validators) {
    const current = stakeMap.get(validator.softwareClient) ?? 0;
    stakeMap.set(validator.softwareClient, current + validator.activeStake);
  }

  return stakeMap;
}
